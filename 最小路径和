题目：
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：
每次只能向下或者向右移动一步。

int minPathSum(int** grid, int gridSize, int* gridColSize){
    int a=gridSize,b=*gridColSize,i,j,miner;
    int p[a][b];
    p[0][0]=grid[0][0];

    for(i=1;i<a;i++)//遍历第一列，使每个元素等于这个元素与上一行元素之和
        p[i][0]=p[i-1][0]+grid[i][0];
    for(i=1;i<b;i++)//遍历第一行，使每个元素等于这个元素与上一列元素之和
        p[0][i]=p[0][i-1]+grid[0][i];
    for(i=1;i<a;i++)
        for(j=1;j<b;j++){
            miner=p[i][j-1]>=p[i-1][j]?p[i-1][j]:p[i][j-1];//比较上方和左方元素的大小，去较小的一个
            p[i][j]=miner+grid[i][j];//将较小的元素与当前元素累加
        }
        
    return p[a-1][b-1];

}
