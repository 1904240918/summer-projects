题目：
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/insertion-sort-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

示例 1：

输入: 4->2->1->3
输出: 1->2->3->4
示例 2：

输入: -1->5->3->4->0
输出: -1->0->3->4->5

struct ListNode* insertionSortList(struct ListNode* head){
    if(head==NULL) return NULL;
    struct ListNode *L=(struct ListNode *)malloc(sizeof(struct ListNode));
    L->next=head;
    L->val=-99999;
    struct ListNode *p=head->next;             //未排序的节点们
    struct ListNode *final_sort_index=head; //排好序的最后一个节点
    struct ListNode *now_cmp=NULL;         //当前要插入的节点
    struct ListNode *insert_index=NULL;   //插入位置
    final_sort_index->next=NULL;
    while(p){
        
        insert_index=L;
        now_cmp=p;
        p=p->next;
        
        if(now_cmp->val>final_sort_index->val){
            final_sort_index->next=now_cmp;
            final_sort_index=now_cmp;
            final_sort_index->next=NULL;
            continue;
        }
        //insert_index->val<now_cmp->val&&L->next->val<now_cmp->val
        while(insert_index->next->val<now_cmp->val){
            //printf("%d ",insert_index->val);
            insert_index=insert_index->next;
        }
        //printf("888\n");
        now_cmp->next=insert_index->next;
        insert_index->next=now_cmp;
        
        
        
    }
    return L->next;
}
