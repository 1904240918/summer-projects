题目：
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL

思路：将链表链接成环，这里要注意链表的移动顺序和移动后的表头的移动顺序是相反的，所以旋转后表头的位置其实是链表的长度-移动的位置。

struct ListNode {
    int val;
    struct ListNode *next;
    }；
    
struct ListNode* rotateRight(struct ListNode* head, int k){
    struct ListNode *p = head;
    int n=1,m;
    
    if(head == NULL||k <= 0)
        return head;//在计算长度前一定要先判断链表是否为空
    while(p->next){//计算链表的长度
        p = p->next;
        n++;
    }

    if(n == 1||k%n == 0)
        return head;
    if(k<n)
        m = n-k-1;//旋转后表头的上一个位置
    else
        m = n-k%n-1;
    
    p->next = head;//将链表链接成环
    p = head;

    while(m){
        p = p->next;
        m--;
    }
    head = p->next;//旋转后的新表头
    p->next = NULL;//将链表断开

    return head;
}
